package xmipp.jni;

public class MDLabel {
   public static final int MDL_UNDEFINED = -1; /// 
   public static final int MDL_FIRST_LABEL = 0;  /// < The label MDL_OBJID is special and should not be used
   public static final int MDL_OBJID = MDL_FIRST_LABEL;  /// < object id (int), NOTE: This label is special and shouldn't be used
   public static final int MDL_GATHER_ID = 1;  ///  Special label to be used when gathering MDs in MpiMetadataPrograms
   public static final int MDL_ANGLE_PSI = 2;  /// < Psi angle of an image (double,degrees)
   public static final int MDL_ANGLE_PSI2 = 3;  /// < Psi angle of an image (double,degrees)
   public static final int MDL_ANGLE_PSI_DIFF = 4;  /// < difference between psi angles (double,degrees)
   public static final int MDL_ANGLE_ROT = 5;  /// < Rotation angle of an image (double,degrees)
   public static final int MDL_ANGLE_ROT2 = 6;  /// < Rotation angle of an image (double,degrees)
   public static final int MDL_ANGLE_ROT_DIFF = 7;  /// < difference between rot angles (double,degrees)
   public static final int MDL_ANGLE_TILT = 8;  /// < Tilting angle of an image (double,degrees)
   public static final int MDL_ANGLE_TILT2 = 9;  /// < Tilting angle of an image (double,degrees)
   public static final int MDL_ANGLE_TILT_DIFF = 10;  /// < difference between tilt angles (double,degrees)
   public static final int MDL_ANGLE_DIFF0 = 11;  /// < difference between two angles (double,degrees)
   public static final int MDL_ANGLE_DIFF = 12;  /// < difference between two angles (double,degrees)
   public static final int MDL_ANGLE_DIFF2 = 13;  /// < difference between two angles (double,degrees)
   public static final int MDL_ANGLE_Y = 14;    /// < Angle between y-axis and tilt-axis (double, degrees) for untilted micrographs
   public static final int MDL_ANGLE_Y2 = 15;    /// < Angle between y-axis and tilt-axis (double, degrees) for tilted micrographs
   public static final int MDL_ANGLE_TEMPERATURE = 16;  /// < Angular temperature (double,degrees)
   public static final int MDL_APPLY_SHIFT = 17; /// <Apply shift when project the volume ,
   public static final int MDL_AVG = 18;  /// < average value (double)
   public static final int MDL_AVG_CHANGES_ORIENTATIONS = 19;  ///  Average change in angular orientation (double degrees)
   public static final int MDL_AVG_CHANGES_OFFSETS = 20;  ///  Average change in offset (double pixels)
   public static final int MDL_AVG_CHANGES_CLASSES = 21;  ///  Average change in class assignment(double dimensionaless)
   public static final int MDL_AVGPMAX = 22;  /// < Average (per class) of the maximum value of normalized probability function) (double)
   public static final int MDL_BGMEAN = 23;  /// < Mean background value for an image
   public static final int MDL_BLOCK_NUMBER = 24;  /// < Current block number (for incremental EM)
   public static final int MDL_CL2D_CHANGES = 25;  /// < Number of changes between iterations
   public static final int MDL_CL2D_SIMILARITY = 26;  /// < Average cross-correlation for the image (double)
   public static final int MDL_CLASS_COUNT = 27;  /// < Number of images assigned to the same class as this image
   public static final int MDL_CLASS_PERCENTAGE = 28;  /// < Percentage of images assigned to the same class as this image
   public static final int MDL_CLASSIFICATION_DATA = 29;  /// < Data vector for classification (vector double)
   public static final int MDL_CLASSIFICATION_DATA_SIZE = 30;  /// < Size of data vectors for classification (int)
   public static final int MDL_CLASSIFICATION_DPR_05 = 31;  /// < Differential Phase Residual evaluated at FRC=0.5
   public static final int MDL_CLASSIFICATION_INTRACLASS_DISTANCE = 32;  /// < Average intraclass distance (double)
   public static final int MDL_CLASSIFICATION_FRC_05 = 33;  /// < Digital frequency at which the FRC drops below 0.5 (double)
   public static final int MDL_COMMENT = 34;  /// < Serve to make annotations on the metadata row
   public static final int MDL_COST = 35;  /// < Cost for the image (double)
   public static final int MDL_COST_PERCENTILE = 36;  /// < Cost percentile for the image (double)
   public static final int MDL_COUNT = 37;  /// < Number of elements of a type (int) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_COUNT2 = 38;  /// < Number of elements of a type (int) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_CRYSTAL_CELLX = 39;  /// < Cell location for crystals
   public static final int MDL_CRYSTAL_CELLY = 40;  /// < Cell location for crystals
   public static final int MDL_CRYSTAL_LATTICE_A = 41;    ///  < Lattice vector for projection (vector double)
   public static final int MDL_CRYSTAL_LATTICE_B = 42;    ///  < Lattice vector for projection (vector double)
   public static final int MDL_CRYSTAL_DISAPPEAR_THRE = 43;    ///  < Disappearing threshold (double)
   public static final int MDL_CRYSTAL_SHFILE = 44;    ///  < Shift file for crystal projection
   public static final int MDL_CRYSTAL_ORTHO_PRJ = 45;    ///  <Orthogonal projection or not (bool)
   public static final int MDL_CRYSTAL_PROJ = 46;    ///  < Have a crystal projection (bool)
   public static final int MDL_CRYSTAL_SHIFTX = 47;  /// < Shift for the image in the X axis (double) for crystals
   public static final int MDL_CRYSTAL_SHIFTY = 48;  /// < Shift for the image in the Y axis (double) for crystals
   public static final int MDL_CRYSTAL_SHIFTZ = 49;  /// < Shift for the image in the Z axis (double) for crystals
   public static final int MDL_CRYSTAL_NOISE_SHIFT  = 50;  /// < noise if center of unit cell (vector double)
   public static final int MDL_CONTINUOUS_X = 51;  /// < X shift of continuous assignment
   public static final int MDL_CONTINUOUS_Y = 52;  /// < Y shift of continuous assignment
   public static final int MDL_CONTINUOUS_FLIP = 53;  /// < Flip of continuous assignment
   public static final int MDL_CONTINUOUS_GRAY_A = 54;  /// < a value of continuous assignment
   public static final int MDL_CONTINUOUS_GRAY_B = 55;  /// < b value of continuous assignment
   public static final int MDL_CONTINUOUS_SCALE_ANGLE = 56;  /// < scale angle of continuous assignment
   public static final int MDL_CONTINUOUS_SCALE_X = 57;  /// < scale x of continuous assignment
   public static final int MDL_CONTINUOUS_SCALE_Y = 58;  /// < scale y of continuous assignment
   public static final int MDL_CTF_DATA_PHASE_FLIPPED = 59; // Is the Data Phase-Flippled? /// 
   public static final int MDL_CTF_CORRECTED = 60; // Is the CTF corrected? /// 
   public static final int MDL_CTF_INPUTPARAMS = 61;  /// < Parameters file for the CTF Model (std::string)
   public static final int MDL_CTF_MODEL = 62;  /// < Name for the CTF Model (std::string)
   public static final int MDL_CTF_MODEL2 = 63;  /// < Name for another CTF model (std::string)
   public static final int MDL_CTF_SAMPLING_RATE = 64;  /// < Sampling rate
   public static final int MDL_CTF_SAMPLING_RATE_Z = 65;  /// < Sampling rate in Z direction
   public static final int MDL_CTF_VOLTAGE = 66;  /// < Microscope voltage (kV)
   public static final int MDL_CTF_DEFOCUSA = 67;  /// < average defocus (Angtroms)
   public static final int MDL_CTF_DEFOCUSU = 68;  /// < Defocus U (Angstroms)
   public static final int MDL_CTF_DEFOCUSV = 69;  /// < Defocus V (Angstroms)
   public static final int MDL_CTF_X0 = 70;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_Y0 = 71;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_XF = 72;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_YF = 73;  /// < The CTF is valid within (x0,y0) to (xF,yF) in the micrograph coordinates
   public static final int MDL_CTF_DEFOCUS_PLANEUA = 74;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEUB = 75;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEUC = 76;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEVA = 77;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEVB = 78;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_PLANEVC = 79;  /// < Defocus = A*x+B*y+C
   public static final int MDL_CTF_DEFOCUS_ANGLE = 80;  /// < Defocus angle (degrees)
   public static final int MDL_CTF_CS = 81;  /// < Spherical aberration
   public static final int MDL_CTF_CA = 82;  /// < Chromatic aberration
   public static final int MDL_CTF_GROUP = 83;  /// < group images by defocus
   public static final int MDL_CTF_ENERGY_LOSS = 84;  /// < Energy loss
   public static final int MDL_CTF_ENVELOPE = 85; //<Envelope function /// 
   public static final int MDL_CTF_ENVELOPE_PLOT = 86; //<Envelope function /// 
   public static final int MDL_CTF_LENS_STABILITY = 87;  /// < Lens stability
   public static final int MDL_CTF_CONVERGENCE_CONE = 88;  /// < Convergence cone
   public static final int MDL_CTF_LONGITUDINAL_DISPLACEMENT = 89;  /// < Longitudinal displacement
   public static final int MDL_CTF_TRANSVERSAL_DISPLACEMENT = 90;  /// < Transversal displacemente
   public static final int MDL_CTF_Q0 = 91;  /// < Inelastic absorption
   public static final int MDL_CTF_K = 92;  /// < CTF gain
   public static final int MDL_CTF_ENV_R0 = 93;  /// < CTF Envelope polynomial parameter
   public static final int MDL_CTF_ENV_R1 = 94;  /// < CTF Envelope polynomial parameter
   public static final int MDL_CTF_ENV_R2 = 95;  /// < CTF Envelope polynomial parameter
   public static final int MDL_CTF_BG_GAUSSIAN_K = 96;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_SIGMAU = 97;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_SIGMAV = 98;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_CU = 99;  /// <CTF_ CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_CV = 100;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN_ANGLE = 101;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_K = 102;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_U = 103;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_V = 104;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_SQRT_ANGLE = 105;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_BASELINE = 106;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_K = 107;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_SIGMAU = 108;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_SIGMAV = 109;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_CU = 110;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_CV = 111;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_GAUSSIAN2_ANGLE = 112;  /// < CTF Background parameter
   public static final int MDL_CTF_BG_R1 = 113;  /// < CTF Background polynomial parameter
   public static final int MDL_CTF_BG_R2 = 114;  /// < CTF Background polynomial parameter
   public static final int MDL_CTF_BG_R3 = 115;  /// < CTF Background polynomial parameter
   public static final int MDL_CTF_CRIT_NONASTIGMATICVALIDITY = 116;  /// < Maximum frequency (in Angstroms) at which non-astigmatic CTF correction is valid
   public static final int MDL_CTF_CRIT_PSDCORRELATION90 = 117;  /// < PSD correlation at 90 degrees
   public static final int MDL_CTF_CRIT_FIRSTZERORATIO = 118;  /// < First zero ratio
   public static final int MDL_CTF_CRIT_FIRSTMINIMUM_FIRSTZERO_RATIO = 119;  /// < Ratio sigma(firstMinimum)/sigma(firstZero)
   public static final int MDL_CTF_CRIT_FIRSTMINIMUM_FIRSTZERO_DIFF_RATIO = 120;  /// < Ratio sigma(firstMinimum-firstZero)/sigma(firstZero)
   public static final int MDL_CTF_CRIT_FIRSTZEROAVG = 121;  /// < First zero average (in Angstroms)
   public static final int MDL_CTF_CRIT_FIRSTZERODISAGREEMENT = 122;  /// < First zero disagreement with second model (in Angstroms)
   public static final int MDL_CTF_CRIT_MAXFREQ = 123;  /// < Maximum frequency at which the envelope drops below 0.1 (in Angstroms)
   public static final int MDL_CTF_CRIT_DAMPING = 124;  /// < Minimum damping at border
   public static final int MDL_CTF_CRIT_PSDRADIALINTEGRAL = 125;  /// < Integral of the radial PSD
   public static final int MDL_CTF_CRIT_FITTINGSCORE = 126;  /// < Score of the fitting
   public static final int MDL_CTF_CRIT_FITTINGCORR13 = 127;  /// < Correlation between the 1st and 3rd ring of the CTF
   public static final int MDL_CTF_CRIT_PSDVARIANCE = 128;  /// < PSD variance
   public static final int MDL_CTF_CRIT_PSDPCA1VARIANCE = 129;  /// < Variance in the first principal component of the PSDs
   public static final int MDL_CTF_CRIT_PSDPCARUNSTEST = 130;  /// < Runs test on the projection of the PSD on the first principal component
   public static final int MDL_CTF_CRIT_NORMALITY = 131;  /// < Normality test between histogram of micrography and gaussian distribution
   public static final int MDL_CTF_CRIT_ICENESS = 132;  /// < Iceness of the micrograph
   public static final int MDL_CTF_DOWNSAMPLE_PERFORMED = 133;  /// < Downsampling performed to estimate the CTF
   public static final int MDL_CTF_DIMENSIONS = 134; // Size in pixels of the 3D PSF to be created (Xdim = 134; Ydim = 134; Zdim) /// 
   public static final int MDL_CTF_LAMBDA = 135;  ///  Wavelength (nm)
   public static final int MDL_CTF_XRAY_LENS_TYPE = 136;  /// Algorithm used to generate Xray PSF
   public static final int MDL_CTF_XRAY_OUTER_ZONE_WIDTH = 137;  ///  Outermost zone width of the X-ray Fresnel lens (nm)
   public static final int MDL_CTF_XRAY_ZONES_NUMBER = 138; // Number of zones of the X-ray Fresnel lens /// 
   public static final int MDL_CTF_PHASE_SHIFT = 139;	//Volta Phase Plate phase shift /// 
   public static final int MDL_CTF_VPP_RADIUS = 140;    //Phase Plate radius /// 
   public static final int MDL_CUMULATIVE_SSNR = 141;  /// <Cumulative SSNR (double)
   public static final int MDL_DATATYPE = 142;  /// < if read from file original image datatype, this is an struct defined in image
   public static final int MDL_DEFGROUP = 143;  /// < Defocus group
   public static final int MDL_DIMRED = 144;  /// < Projection onto a reduced manifold (vector double)
   public static final int MDL_DIRECTION = 145;  /// < Direction in 3D
   public static final int MDL_DM3_IDTAG = 146; /// 
   public static final int MDL_DM3_NODEID = 147; /// 
   public static final int MDL_DM3_NUMBER_TYPE = 148; /// 
   public static final int MDL_DM3_PARENTID = 149; /// 
   public static final int MDL_DM3_TAGCLASS = 150; /// 
   public static final int MDL_DM3_TAGNAME = 151; /// 
   public static final int MDL_DM3_SIZE = 152; /// 
   public static final int MDL_DM3_VALUE = 153; /// 
   public static final int MDL_ENABLED = 154;  /// < Is this image enabled? (int [-1 or 1])
   public static final int MDL_DATE = 155;// < timestamp (string) /// 
   public static final int MDL_TIME = 156;// <  time in seconds (double) /// 
   public static final int MDL_FLIP = 157;  /// < Flip the image? (bool)
   public static final int MDL_FOM = 158;  /// < Figure of Merit in 0-1 range (double)
   public static final int MDL_FRAME_ID = 159;  /// < Unique id of frame inside a Movie
   public static final int MDL_IDX = 160;  /// < Index within a list (size_t)
   public static final int MDL_IMAGE = 161;  /// < Name of an image (std::string)
   public static final int MDL_IMAGE_COVARIANCE = 162;  /// < Name of the covariance imagee associated to this image
   public static final int MDL_IMAGE_IDX = 163;  /// < Index of an image within a list (size_t)
   public static final int MDL_IMAGE_ORIGINAL = 164;  /// < Name of an image from which MDL_IMAGE is coming from
   public static final int MDL_IMAGE_REF = 165;  /// < Name of of the class image from which MDL_IMAGE is coming from
   public static final int MDL_IMAGE_RESIDUAL = 166;  /// < Name of a residual image associated to this image
   public static final int MDL_IMAGE_TILTED = 167;  /// < Name of the tilted images associated to MDL_IMAGE
   public static final int MDL_IMGMD = 168;  /// < Name of Metadata file for all images (string)
   public static final int MDL_IMAGE1 = 169;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE2 = 170;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE3 = 171;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE4 = 172;  /// < Image associated to this object (std::string)
   public static final int MDL_IMAGE5 = 173;  /// < Image associated to this object (std::string)
   public static final int MDL_INTSCALE = 174;  /// < Intensity scale for an image
   public static final int MDL_ITEM_ID = 175;  /// < Unique identifier for items inside a list or set (std::size_t)
   public static final int MDL_ITER = 176;  /// < Current iteration number (int)
   public static final int MDL_KERDENSOM_FUNCTIONAL = 177;  /// < Functional value (double)
   public static final int MDL_KERDENSOM_REGULARIZATION = 178;  /// < Regularization value (double)
   public static final int MDL_KERDENSOM_SIGMA = 179;  /// < Sigma value (double)
   public static final int MDL_KEYWORDS = 180;  /// < Keywords associated to this line, should be a single string block (do not use spaces as separators)
   public static final int MDL_KSTEST = 181;  /// <KS-test statistics
   public static final int MDL_LL = 182;  /// < contribution of an image to log-likelihood value
   public static final int MDL_MAGNIFICATION = 183;  ///  Magnification of microscope
   public static final int MDL_MAPTOPOLOGY = 184;  /// < Map topology (KerDenSOM, ...)
   public static final int MDL_MASK = 185;  /// < Name of a mask associated to image
   public static final int MDL_MAXCC = 186;  /// < Maximum cross-correlation for the image (double)
   public static final int MDL_MAXCC_PERCENTILE = 187;  /// < Percentile of the maximum cross-correlation for the image (double)
   public static final int MDL_MAX = 188;  /// < Maximum value (double)
   public static final int MDL_MICROGRAPH = 189;  /// < Name of a micrograph (std::string)
   public static final int MDL_MICROGRAPH_ID = 190;  /// < Micrograph unique id for reference (MDL_ITEM_ID should be used for Micrographs list)
   public static final int MDL_MICROGRAPH_MOVIE = 191;  /// < Name of a movie (std::string)
   public static final int MDL_MICROGRAPH_MOVIE_ID = 192;  /// < Unique identifier of a movie.
   public static final int MDL_MICROGRAPH_PARTICLES = 193;  /// < Name of a position file (std::string)
   public static final int MDL_MICROGRAPH_ORIGINAL = 194;  /// < Name of the original micrograph, MDL_MICROGRAPH is probably a downsampled version of this one (std::string)
   public static final int MDL_MICROGRAPH_TILTED = 195;  /// < Name of the corresponding tilted micrograph (std::string)
   public static final int MDL_MICROGRAPH_TILTED_ORIGINAL = 196;  /// < Name of the corresponding original, tilted micrograph (std::string)
   public static final int MDL_MIN = 197;  /// < Minimum value (double)
   public static final int MDL_MIRRORFRAC = 198;  /// < Mirror fraction for a Maximum Likelihood model
   public static final int MDL_MISSINGREGION_NR = 199;  /// < Number of missing region in subtomogram
   public static final int MDL_MISSINGREGION_TYPE = 200;  /// < Type of missing region in subtomogram
   public static final int MDL_MISSINGREGION_THY0 = 201;  /// < Initial tilt angle in Y for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THYF = 202;  /// < Final tilt angle in Y for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THX0 = 203;  /// < Initial tilt angle in X for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THXF = 204;  /// < Final tilt angle in X for missing region in subtomogram
   public static final int MDL_MLF_CTF = 205;     /// < MLF CTF estimated value (double)
   public static final int MDL_MLF_WIENER = 206;  /// < MLF Wiener filter (double)
   public static final int MDL_MLF_SIGNAL = 207;  /// < MLF signal (double)
   public static final int MDL_MLF_NOISE = 208;   /// < MLF Wiener filter (double)
   public static final int MDL_MODELFRAC = 209;  /// < Model fraction (alpha_k) for a Maximum Likelihood model
   public static final int MDL_NEIGHBORS = 210;  /// < Vector of indexes to points some "neighbors"
   public static final int MDL_NEIGHBOR = 211;  /// < Particular neighbor (pointed myNEIGHBORS)
   public static final int MDL_NEIGHBORHOOD_RADIUS = 212;  /// < Radius of the neighborhood (radians)
   public static final int MDL_NMA = 213;  /// < Normal mode displacements (vector double)
   public static final int MDL_NMA_COLLECTIVITY = 214;  /// < NMA Collectivity of a given mode
   public static final int MDL_NMA_ATOMSHIFT = 215;  /// < NMA Atom shift in Angstroms
   public static final int MDL_NMA_ENERGY = 216;  /// < NMA energy contained in the NMA displacement vector
   public static final int MDL_NMA_MINRANGE = 217;  /// < Minimum value observed for a given NMA mode
   public static final int MDL_NMA_MAXRANGE = 218;  /// < Maximum value observed for a given NMA mode
   public static final int MDL_NMA_MODEFILE = 219;  /// < File with an NMA mode
   public static final int MDL_NMA_SCORE = 220;  /// < NMA Score of a given mode
   public static final int MDL_NOISE_ANGLES = 221;  /// < Noise description for projected angles
   public static final int MDL_NOISE_PARTICLE_COORD = 222;  /// < Noise description for particle's center coordenates (when projecting)
   public static final int MDL_NOISE_COORD = 223;  //Use instead of MDL_NOISE_PARTICLE_COORD in future /// 
   public static final int MDL_NOISE_PIXEL_LEVEL = 224;  /// < Noise description for pixels' gray level (when projecting)
   public static final int MDL_ORDER = 225;  ///  auxiliary label to be used as an index (long)
   public static final int MDL_ORIGIN_X = 226;  /// < Origin for the image in the X axis (double)
   public static final int MDL_ORIGIN_Y = 227;  /// < Origin for the image in the Y axis (double)
   public static final int MDL_ORIGIN_Z = 228;  /// < Origin for the image in the Z axis (double)
   public static final int MDL_OPTICALFLOW_MEANX = 229;  /// <Mean of the movement in x direction of the motion map> (double)
   public static final int MDL_OPTICALFLOW_MEANY = 230;  /// <Mean of the movement in y direction of the motion map> (double)
   public static final int MDL_OPTICALFLOW_STDX = 231;  /// <Standatd deviation of the movement in x direction of the motion map> (double)
   public static final int MDL_OPTICALFLOW_STDY = 232;  /// <Standard deviation of the movement in y direction of the motion map> (double)
   public static final int MDL_PARTICLE_ID = 233;  /// < Particle unique identifier for reference. (The MDL_ITEM_ID should be used when particle list)
   public static final int MDL_PHANTOM_BGDENSITY = 234;  /// < Phantom background density (double)
   public static final int MDL_PHANTOM_FEATURE_CENTER = 235;  /// < Center of the feature (vector double)
   public static final int MDL_PHANTOM_FEATURE_DENSITY = 236;  /// < The density of the feature (double)
   public static final int MDL_PHANTOM_FEATURE_OPERATION = 237;  /// < Operation in case of overlapping features (+,-)
   public static final int MDL_PHANTOM_FEATURE_SPECIFIC = 238;  /// < Specific parameters for a feature (vector double)
   public static final int MDL_PHANTOM_FEATURE_TYPE = 239;  /// < Type of the feature (Sphere, Blob, ...) (std::string)
   public static final int MDL_PHANTOM_SCALE = 240;  /// < Number which will multiply all features (double)
   public static final int MDL_MACRO_CMD = 241; //ImageJ macro command on picker /// 
   public static final int MDL_MACRO_CMD_ARGS = 242; //ImageJ macro args on picker /// 
   public static final int MDL_COLOR = 243;  /// < Color for particle picking
   public static final int MDL_PICKING_TEMPLATES = 244;  /// < Number of templates
   public static final int MDL_PICKING_STATE = 245;  /// < State for particle picking
   public static final int MDL_PICKING_MICROGRAPH_STATE = 246;  /// < Micrograph state for particle picking
   public static final int MDL_PICKING_AUTOPICKPERCENT = 247; /// 
   public static final int MDL_PICKING_PARTICLE_SIZE = 248;  /// < Particle size for particle picking
   public static final int MDL_PICKING_AUTOPARTICLES_SIZE = 249;  /// < Number of automatic particles picked
   public static final int MDL_PICKING_MANUALPARTICLES_SIZE = 250;  /// < Number of manual particles picked
   public static final int MDL_PMAX = 251;  /// < Maximum value of normalized probability function (now called "Pmax/sumP") (double)
   public static final int MDL_POINTSASYMETRICUNIT = 252;  ///  < Number of non-redundant projections directions (size_t)
   public static final int MDL_PRJ_DIMENSIONS = 253; // X = 253;Y dimensions for the generated projections /// 
   public static final int MDL_PRJ_ANGFILE = 254;   /// < File for generated angles
   public static final int MDL_PRJ_PSI_NOISE = 255;   ///  < Psi angle dev and mean noise (vector double)
   public static final int MDL_PRJ_PSI_RANDSTR = 256;  ///  < Type of randomness for Psi (std::string)
   public static final int MDL_PRJ_PSI_RANGE = 257;   ///  < Psi angle range (vector double)
   public static final int MDL_PRJ_ROT_NOISE  = 258;   ///  < Rotational angle dev and mean noise (vector double)
   public static final int MDL_PRJ_ROT_RANDSTR = 259;   ///  < Type of randomness for Rotational (std::string)
   public static final int MDL_PRJ_ROT_RANGE = 260; /// 
   public static final int MDL_PRJ_TILT_NOISE = 261;   ///  < Tilt angle dev and mean noise (vector double)
   public static final int MDL_PRJ_TILT_RANDSTR = 262;   ///  < Type of randomness for Tilt (std::string)
   public static final int MDL_PRJ_TILT_RANGE = 263; // Vector with the initial and final tilt angle values = 263; and step size /// 
   public static final int MDL_PRJ_VOL = 264;        // Volume file name to generate projections from /// 
   public static final int MDL_PROGRAM = 265;// <  program name /// 
   public static final int MDL_USER = 266;// <  user name /// 
   public static final int MDL_DIMENSIONS_3D = 267;  // X = 267;Y = 267;Z dimensions /// 
   public static final int MDL_DIMENSIONS_2D = 268;  // X = 268;Y dimensions /// 
   public static final int MDL_PSD = 269;  /// < A Power Spectrum Density file name (std::string)
   public static final int MDL_PSD_ENHANCED = 270;  /// < A enhanced Power Spectrum Density file name (std::string)
   public static final int MDL_RANDOMSEED = 271;  /// < Seed for random number generator
   public static final int MDL_REF3D = 272;  /// < 3D Class to which the image belongs (int)
   public static final int MDL_REF = 273;  /// < Class to which the image belongs (int)
   public static final int MDL_REF2 = 274;  /// < Store a second class (int)
   public static final int MDL_REFMD = 275;  /// < Name of Metadata file for all references(string)
   public static final int MDL_RESOLUTION_DPR = 276;  /// <differential phase residual (double)
   public static final int MDL_RESOLUTION_ERRORL2 = 277;  /// <Error in l2 (double)
   public static final int MDL_RESOLUTION_FRC = 278;  /// <Fourier shell correlation (double)
   public static final int MDL_RESOLUTION_FRCRANDOMNOISE = 279;  /// <Fourier shell correlation noise (double)
   public static final int MDL_RESOLUTION_FREQ = 280;  /// <Frequency in 1/A (double)
   public static final int MDL_RESOLUTION_FREQ2 = 281;  /// < Frequency in 1/A squared (double)
   public static final int MDL_RESOLUTION_FREQREAL = 282;  /// < Frequency in A (double)
   public static final int MDL_RESOLUTION_LOG_STRUCTURE_FACTOR = 283;  /// <Logarithm of the structure factor
   public static final int MDL_RESOLUTION_SSNR = 284;  /// <Fourier shell correlation (double)
   public static final int MDL_RESOLUTION_STRUCTURE_FACTOR = 285;  /// <Structure factor
   public static final int MDL_RESOLUTION_RFACTOR = 286;  ///  rfactor
   public static final int MDL_SAMPLINGRATE = 287;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_ORIGINAL = 288;  /// < original sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_X = 289;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_Y = 290;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATE_Z = 291;  /// < sampling rate in A/pixel (double)
   public static final int MDL_SCALE = 292;  /// < scaling factor for an image or volume (double)
   public static final int MDL_SCORE_BY_PCA_RESIDUAL_PROJ = 293; /// 
   public static final int MDL_SCORE_BY_PCA_RESIDUAL_EXP = 294; /// 
   public static final int MDL_SCORE_BY_PCA_RESIDUAL = 295; /// 
   public static final int MDL_SCORE_BY_ALIGNABILITY = 296;  /// < score by alignability (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_PRECISION = 297;  /// < score by alignability (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_ACCURACY = 298;  /// < score by alignability (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_PRECISION_EXP = 299;  /// < score by alignability experimental particles (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_PRECISION_REF = 300;  /// < score by alignability references (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_ACCURACY_EXP = 301;  /// < score by alignability experimental particles (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_ACCURACY_REF = 302;  /// < score by alignability references (double)
   public static final int MDL_SCORE_BY_ALIGNABILITY_NOISE = 303;  /// < score by alignability noise (double)
   public static final int MDL_SCORE_BY_EMPTINESS = 304;  /// < Small values represent worse particles. Much larger than 1 for good particles
   public static final int MDL_SCORE_BY_ENTROPY = 305;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_GRANULO = 306;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_LBP = 307;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_MIRROR = 308;  /// < score by mirror (double)
   public static final int MDL_SCORE_BY_RAMP = 309;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_SCREENING = 310;  /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_VARIANCE = 311;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_VAR = 312;  ///  < Particle variance (double)
   public static final int MDL_SCORE_BY_GINI = 313;  ///  < Micrographs Gini Coeff. (double)
   public static final int MDL_SCORE_BY_ZERNIKE = 314;   /// < Feature vectors used to classify particles (vector double)
   public static final int MDL_SCORE_BY_ZSCORE = 315; /// 
   public static final int MDL_SELFILE = 316;  /// < Name of an image (std::string)
   public static final int MDL_SERIE = 317;  /// < A collection of micrographs, e.g. a tilt serie (std::string)
   public static final int MDL_SHIFT_X = 318;  /// < Shift for the image in the X axis (double)
   public static final int MDL_SHIFT_X2 = 319;  /// < Shift for the image in the X axis (double)
   public static final int MDL_SHIFT_X_DIFF = 320;  /// < difference in Shift along X axis (double)
   public static final int MDL_SHIFT_Y = 321;  /// < Shift for the image in the Y axis (double)
   public static final int MDL_SHIFT_Y2 = 322;  /// < Shift for the image in the Y axis (double)
   public static final int MDL_SHIFT_Y_DIFF = 323;  /// < difference in Shift along  Y axis (double)
   public static final int MDL_SHIFT_Z = 324;  /// < Shift for the image in the Z axis (double)
   public static final int MDL_SHIFT_DIFF0 = 325;  /// < shift difference (double)
   public static final int MDL_SHIFT_DIFF = 326;  /// < shift difference (double)
   public static final int MDL_SHIFT_DIFF2 = 327;  /// < shift difference (double)
   public static final int MDL_SIGMANOISE = 328;  /// < Standard deviation of the noise in ML model
   public static final int MDL_SIGMAOFFSET = 329;  /// < Standard deviation of the offsets in ML model
   public static final int MDL_SIGNALCHANGE = 330;  /// < Signal change for an image
   public static final int MDL_STDDEV = 331;  /// <stdandard deviation value (double)
   public static final int MDL_STAR_COMMENT = 332;  /// < A comment for this object /*** NOTE THIS IS A SPECIAL CASE AND SO IS TREATED ***/
   public static final int MDL_SUM = 333;  /// < Sum of elements of a given type (double) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_SUMWEIGHT = 334;  /// < Sum of all weights in ML model
   public static final int MDL_SYMNO = 335;  /// < Symmetry number for a projection (used in ART)
   public static final int MDL_TOMOGRAM_VOLUME = 336;  /// < Name for the reconstructed tomogram volume (std::string)
   public static final int MDL_TOMOGRAMMD = 337;  /// < Name for a Metadata file (std::string)
   public static final int MDL_TRANSFORM_MATRIX = 338;  /// < transformation matrix in numpy string format or space separated (std::string)
   public static final int MDL_TEST_SIZE = 339;// < number of test assigned to a program /// 
   public static final int MDL_VOLUME_SCORE_SUM = 340;  ///  < Score corresponding to the sum of cc with cc>threshold
   public static final int MDL_VOLUME_SCORE_SUM_TH = 341;  /// < Score corresponding to the sum of cc-threshold with cc>threshold
   public static final int MDL_VOLUME_SCORE_MEAN = 342;  /// < Score corresponding to the mean of cc with cc>threshold
   public static final int MDL_VOLUME_SCORE_MIN = 343;  /// < Score corresponding to the min of cc with cc>threshold
   public static final int MDL_VOLUME_SCORE1 = 344; ///  < Score 1 for volumes
   public static final int MDL_VOLUME_SCORE2 = 345; ///  < Score 2 for volumes
   public static final int MDL_VOLUME_SCORE3 = 346; ///  < Score 3 for volumes
   public static final int MDL_VOLUME_SCORE4 = 347; ///  < Score 4 for volumes
   public static final int MDL_WEIGHT = 348;  /// < Weight assigned to the image (double)
   public static final int MDL_WEIGHT_P = 349;  /// < Weight assigned to the image accordint to its clusterability with a significance with respect noise (double)
   public static final int MDL_WEIGHT_CONTINUOUS2 = 350;  /// < Weight due to angular continuous assignment
   public static final int MDL_WEIGHT_JUMPER0 = 351;  /// < Weight due to angular jumping
   public static final int MDL_WEIGHT_JUMPER = 352;  /// < Weight due to angular jumping
   public static final int MDL_WEIGHT_JUMPER2 = 353;  /// < Weight due to angular jumping
   public static final int MDL_WEIGHT_SIGNIFICANT = 354;  /// < Weight due to Angular significance
   public static final int MDL_WEIGHT_SSNR = 355;  /// < Weight due to SSNR
   public static final int MDL_WEIGHT_PRECISION_ALIGNABILITY = 356;  /// < Weight due to Alignability Precision
   public static final int MDL_WEIGHT_ALIGNABILITY = 357;  /// < Weight due to Alignability Precision and Accuracy
   public static final int MDL_WEIGHT_ACCURACY_ALIGNABILITY = 358;  /// < Weight due to Alignability Accuracy
   public static final int MDL_WEIGHT_PRECISION_MIRROR = 359;  /// < Weight due to Mirror Precision
   public static final int MDL_WROBUST = 360;  /// < Weight of t-student distribution in robust Maximum likelihood
   public static final int MDL_X = 361;  /// < X component (double)
   public static final int MDL_XCOOR = 362;  /// < X component (int)
   public static final int MDL_XCOOR_TILT = 363;  /// < X component in tilted micrograph (int)
   public static final int MDL_XSIZE = 364;  /// < X size (int)
   public static final int MDL_Y = 365;  /// < Y component (double)
   public static final int MDL_YCOOR = 366;  /// < Y component (int)
   public static final int MDL_YCOOR_TILT = 367;  /// < Y component in tilted micrograph (int)
   public static final int MDL_YSIZE = 368;  /// < Y size (int)
   public static final int MDL_Z = 369;  /// < Z component (double)
   public static final int MDL_ZCOOR = 370;  /// < Z component (int)
   public static final int MDL_ZSCORE = 371;  /// < Global Z Score (double)
   public static final int MDL_ZSCORE_HISTOGRAM = 372;  /// < Z Score (double)
   public static final int MDL_ZSCORE_RESMEAN = 373;  /// < Z Score of the mean of the residuals (double)
   public static final int MDL_ZSCORE_RESVAR = 374;  /// < Z Score of the stddev of the residuals (double)
   public static final int MDL_ZSCORE_RESCOV = 375;  /// < Z Score of the covariance matrix of the residuals (double)
   public static final int MDL_ZSCORE_SHAPE1 = 376;  /// < Z Score (double)
   public static final int MDL_ZSCORE_SHAPE2 = 377;  /// < Z Score (double)
   public static final int MDL_ZSCORE_SNR1 = 378;  /// < Z Score (double)
   public static final int MDL_ZSCORE_SNR2 = 379;  /// < Z Score (double)
   public static final int MDL_ZSIZE = 380;  /// < Z size (int)
   public static final int RLN_AREA_ID = 381;  /// < ID for the area (or field of view). If one does not use (tilt) series, area would be the same as micrograph...
   public static final int RLN_AREA_NAME = 382;  /// < Name for the area (or field of view). If one does not use (tilt) series, area would be the same as micrograph...
   public static final int RLN_COMMENT = 383; // The RLN_COMMENT is handled specially as well /// 
   public static final int RLN_CTF_BFACTOR = 384;  /// < B-factor
   public static final int RLN_CTF_SCALEFACTOR = 385;  /// < linear scale-factor
   public static final int RLN_CTF_SAMPLING_RATE = 386;  /// < Sampling rate
   public static final int RLN_CTF_VOLTAGE = 387;  /// < Microscope voltage (kV)
   public static final int RLN_CTF_DEFOCUSU = 388;  /// < Defocus U (Angstroms)
   public static final int RLN_CTF_DEFOCUSV = 389;  /// < Defocus V (Angstroms)
   public static final int RLN_CTF_DEFOCUS_ANGLE = 390;  /// < Defocus angle (degrees)
   public static final int RLN_CTF_CS = 391;  /// < Spherical aberration
   public static final int RLN_CTF_CA = 392;  /// < Chromatic aberration
   public static final int RLN_CTF_DETECTOR_PIXEL_SIZE = 393;  /// < Pixel size for detector as used in CTF-determination
   public static final int RLN_CTF_ENERGY_LOSS = 394;  /// < Energy loss
   public static final int RLN_CTF_FOM = 395;  /// < ctffind3 FOM (CC) for quality of CTF-fit
   public static final int RLN_CTF_IMAGE = 396;  /// < name of an image describing the CTF model
   public static final int RLN_CTF_LENS_STABILITY = 397;  /// < Lens stability
   public static final int RLN_CTF_MAGNIFICATION = 398;  /// < Magnification used for CTF-determination
   public static final int RLN_CTF_MAXRES = 399;  /// < Maximum resolution with Thon rings
   public static final int RLN_CTF_CONVERGENCE_CONE = 400;  /// < Convergence cone
   public static final int RLN_CTF_LONGITUDINAL_DISPLACEMENT = 401;  /// < Longitudinal displacement
   public static final int RLN_CTF_TRANSVERSAL_DISPLACEMENT = 402;  /// < Transversal displacemente
   public static final int RLN_CTF_Q0 = 403;  /// < Amplitude contrast
   public static final int RLN_CTF_K = 404;  /// < CTF gain
   public static final int RLN_CTF_VALUE = 405;  /// < CTF value
   public static final int RLN_CTF_VALIDATIONSCORE = 406;  /// < Gctf-based validation score for CTF fit
   public static final int RLN_CTF_PHASESHIFT = 407;  /// < Phase-shift from a phase-plate (in degrees)
   public static final int RLN_IMAGE_NAME = 408; /// 
   public static final int RLN_IMAGE_RECONSTRUCT_NAME = 409; /// 
   public static final int RLN_IMAGE_ID = 410; /// 
   public static final int RLN_IMAGE_ENABLED = 411; /// 
   public static final int RLN_IMAGE_DATATYPE = 412; /// 
   public static final int RLN_IMAGE_DIMENSIONALITY = 413; /// 
   public static final int RLN_IMAGE_BEAMTILT_X = 414; /// 
   public static final int RLN_IMAGE_BEAMTILT_Y = 415; /// 
   public static final int RLN_IMAGE_BEAMTILT_GROUP = 416; /// 
   public static final int RLN_IMAGE_COORD_X = 417; /// 
   public static final int RLN_IMAGE_COORD_Y = 418; /// 
   public static final int RLN_IMAGE_COORD_Z = 419; /// 
   public static final int RLN_IMAGE_FRAME_NR = 420; /// 
   public static final int RLN_IMAGE_MAGNIFICATION_CORRECTION = 421; /// 
   public static final int RLN_IMAGE_NORM_CORRECTION = 422; /// 
   public static final int RLN_IMAGE_ORI_NAME = 423; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE = 424; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE_X = 425; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE_Y = 426; /// 
   public static final int RLN_IMAGE_SAMPLINGRATE_Z = 427; /// 
   public static final int RLN_IMAGE_SIZE = 428; /// 
   public static final int RLN_IMAGE_SIZEX = 429; /// 
   public static final int RLN_IMAGE_SIZEY = 430; /// 
   public static final int RLN_IMAGE_SIZEZ = 431; /// 
   public static final int RLN_IMAGE_STATS_MIN = 432; /// 
   public static final int RLN_IMAGE_STATS_MAX = 433; /// 
   public static final int RLN_IMAGE_STATS_AVG = 434; /// 
   public static final int RLN_IMAGE_STATS_STDDEV = 435; /// 
   public static final int RLN_IMAGE_STATS_SKEW = 436; /// 
   public static final int RLN_IMAGE_STATS_KURT = 437; /// 
   public static final int RLN_IMAGE_WEIGHT = 438; /// 
   public static final int RLN_MASK_NAME = 439; /// 
   public static final int RLN_MATRIX_1_1 = 440; /// 
   public static final int RLN_MATRIX_1_2 = 441; /// 
   public static final int RLN_MATRIX_1_3 = 442; /// 
   public static final int RLN_MATRIX_2_1 = 443; /// 
   public static final int RLN_MATRIX_2_2 = 444; /// 
   public static final int RLN_MATRIX_2_3 = 445; /// 
   public static final int RLN_MATRIX_3_1 = 446; /// 
   public static final int RLN_MATRIX_3_2 = 447; /// 
   public static final int RLN_MATRIX_3_3 = 448; /// 
   public static final int RLN_MICROGRAPH_ID = 449; /// 
   public static final int RLN_MICROGRAPH_MOVIE_NAME = 450; /// 
   public static final int RLN_MICROGRAPH_NAME = 451; /// 
   public static final int RLN_MICROGRAPH_NAME_WODOSE = 452; /// 
   public static final int RLN_MICROGRAPH_TILT_ANGLE = 453; /// 
   public static final int RLN_MICROGRAPH_TILT_AXIS_DIRECTION = 454; /// 
   public static final int RLN_MICROGRAPH_TILT_AXIS_OUTOFPLANE = 455; /// 
   public static final int RLN_MLMODEL_ACCURACY_ROT = 456; /// 
   public static final int RLN_MLMODEL_ACCURACY_TRANS = 457; /// 
   public static final int RLN_MLMODEL_AVE_PMAX = 458; /// 
   public static final int RLN_MLMODEL_CURRENT_RESOLUTION = 459; /// 
   public static final int RLN_MLMODEL_CURRENT_SIZE = 460; /// 
   public static final int RLN_MLMODEL_DATA_VS_PRIOR_REF = 461; /// 
   public static final int RLN_MLMODEL_DIMENSIONALITY = 462; /// 
   public static final int RLN_MLMODEL_DIMENSIONALITY_DATA = 463; /// 
   public static final int RLN_MLMODEL_DIFF2_HALVES_REF = 464; /// 
   public static final int RLN_MLMODEL_ESTIM_RESOL_REF = 465; /// 
   public static final int RLN_MLMODEL_FOURIER_COVERAGE_REF = 466; /// 
   public static final int RLN_MLMODEL_FOURIER_COVERAGE_TOTAL_REF = 467; /// 
   public static final int RLN_MLMODEL_FSC_HALVES_REF = 468; /// 
   public static final int RLN_MLMODEL_GROUP_NAME = 469; /// 
   public static final int RLN_MLMODEL_GROUP_NO = 470; /// 
   public static final int RLN_MLMODEL_GROUP_NR_PARTICLES = 471; /// 
   public static final int RLN_MLMODEL_GROUP_SCALE_CORRECTION = 472; /// 
   public static final int RLN_MLMODEL_HELICAL_NR_ASU = 473; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST = 474; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST_MIN = 475; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST_MAX = 476; /// 
   public static final int RLN_MLMODEL_HELICAL_TWIST_INITIAL_STEP = 477; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE = 478; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE_MIN = 479; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE_MAX = 480; /// 
   public static final int RLN_MLMODEL_HELICAL_RISE_INITIAL_STEP = 481; /// 
   public static final int RLN_MLMODEL_IS_HELIX = 482; /// 
   public static final int RLN_MLMODEL_INTERPOLATOR = 483; /// 
   public static final int RLN_MLMODEL_LL = 484; /// 
   public static final int RLN_MLMODEL_MINIMUM_RADIUS_NN_INTERPOLATION = 485; /// 
   public static final int RLN_MLMODEL_NORM_CORRECTION_AVG = 486; /// 
   public static final int RLN_MLMODEL_NR_BODIES = 487; /// 
   public static final int RLN_MLMODEL_NR_CLASSES = 488; /// 
   public static final int RLN_MLMODEL_NR_GROUPS = 489; /// 
   public static final int RLN_MLMODEL_ORIGINAL_SIZE = 490; /// 
   public static final int RLN_MLMODEL_ORIENTABILITY_CONTRIBUTION = 491; /// 
   public static final int RLN_MLMODEL_PADDING_FACTOR = 492; /// 
   public static final int RLN_MLMODEL_PDF_CLASS = 493; /// 
   public static final int RLN_MLMODEL_PRIOR_OFFX_CLASS = 494; /// 
   public static final int RLN_MLMODEL_PRIOR_OFFY_CLASS = 495; /// 
   public static final int RLN_MLMODEL_PDF_ORIENT = 496; /// 
   public static final int RLN_MLMODEL_PIXEL_SIZE = 497; /// 
   public static final int RLN_MLMODEL_POWER_REF = 498; /// 
   public static final int RLN_MLMODEL_PRIOR_MODE = 499; /// 
   public static final int RLN_MLMODEL_SGD_GRADIENT_IMAGE = 500; /// 
   public static final int RLN_MLMODEL_SIGMA_OFFSET = 501; /// 
   public static final int RLN_MLMODEL_SIGMA_ROT = 502; /// 
   public static final int RLN_MLMODEL_SIGMA_TILT = 503; /// 
   public static final int RLN_MLMODEL_SIGMA_PSI = 504; /// 
   public static final int RLN_MLMODEL_REF_IMAGE = 505; /// 
   public static final int RLN_MLMODEL_SIGMA2_NOISE = 506; /// 
   public static final int RLN_MLMODEL_SIGMA2_REF = 507; /// 
   public static final int RLN_MLMODEL_SSNR_REF = 508; /// 
   public static final int RLN_MLMODEL_TAU2_FUDGE_FACTOR = 509; /// 
   public static final int RLN_MLMODEL_TAU2_REF = 510; /// 
   public static final int RLN_OPTIMISER_ACCURACY_ROT = 511; /// 
   public static final int RLN_OPTIMISER_ACCURACY_TRANS = 512; /// 
   public static final int RLN_OPTIMISER_ADAPTIVE_FRACTION = 513; /// 
   public static final int RLN_OPTIMISER_ADAPTIVE_OVERSAMPLING = 514; /// 
   public static final int RLN_OPTIMISER_AUTO_LOCAL_HP_ORDER = 515; /// 
   public static final int RLN_OPTIMISER_AVAILABLE_MEMORY = 516; /// 
   public static final int RLN_OPTIMISER_BEST_RESOL_THUS_FAR = 517; /// 
   public static final int RLN_OPTIMISER_CHANGES_OPTIMAL_OFFSETS = 518; /// 
   public static final int RLN_OPTIMISER_CHANGES_OPTIMAL_ORIENTS = 519; /// 
   public static final int RLN_OPTIMISER_CHANGES_OPTIMAL_CLASSES = 520; /// 
   public static final int RLN_OPTIMISER_COARSE_SIZE = 521; /// 
   public static final int RLN_OPTIMISER_DATA_ARE_CTF_PHASE_FLIPPED = 522; /// 
   public static final int RLN_OPTIMISER_DATA_ARE_CTF_PREMULTIPLIED = 523; /// 
   public static final int RLN_OPTIMISER_DATA_STARFILE = 524; /// 
   public static final int RLN_OPTIMISER_DO_AUTO_REFINE = 525; /// 
   public static final int RLN_OPTIMISER_DO_ONLY_FLIP_CTF_PHASES = 526; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_CTF = 527; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_MAGNIFICATION = 528; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_NORM = 529; /// 
   public static final int RLN_OPTIMISER_DO_CORRECT_SCALE = 530; /// 
   public static final int RLN_OPTIMISER_DO_HELICAL_REFINE = 531; /// 
   public static final int RLN_OPTIMISER_DO_REALIGN_MOVIES = 532; /// 
   public static final int RLN_OPTIMISER_DO_MAP = 533; /// 
   public static final int RLN_OPTIMISER_DO_SGD = 534; /// 
   public static final int RLN_OPTIMISER_DO_SOLVENT_FLATTEN = 535; /// 
   public static final int RLN_OPTIMISER_DO_SKIP_ALIGN = 536; /// 
   public static final int RLN_OPTIMISER_DO_SKIP_ROTATE = 537; /// 
   public static final int RLN_OPTIMISER_DO_SPLIT_RANDOM_HALVES = 538; /// 
   public static final int RLN_OPTIMISER_DO_ZERO_MASK = 539; /// 
   public static final int RLN_OPTIMISER_FIX_SIGMA_NOISE = 540; /// 
   public static final int RLN_OPTIMISER_FIX_SIGMA_OFFSET = 541; /// 
   public static final int RLN_OPTIMISER_FIX_TAU = 542; /// 
   public static final int RLN_OPTIMISER_HAS_CONVERGED = 543; /// 
   public static final int RLN_OPTIMISER_HAS_HIGH_FSC_AT_LIMIT = 544; /// 
   public static final int RLN_OPTIMISER_HAS_LARGE_INCR_SIZE_ITER_AGO = 545; /// 
   public static final int RLN_OPTIMISER_HELICAL_TWIST_INITIAL = 546; /// 
   public static final int RLN_OPTIMISER_HELICAL_RISE_INITIAL = 547; /// 
   public static final int RLN_OPTIMISER_HELICAL_Z_PERCENTAGE = 548; /// 
   public static final int RLN_OPTIMISER_HELICAL_TUBE_INNER_DIAMETER = 549; /// 
   public static final int RLN_OPTIMISER_HELICAL_TUBE_OUTER_DIAMETER = 550; /// 
   public static final int RLN_OPTIMISER_HELICAL_SYMMETRY_LOCAL_REFINEMENT = 551; /// 
   public static final int RLN_OPTIMISER_HELICAL_SIGMA_DISTANCE = 552; /// 
   public static final int RLN_OPTIMISER_HIGHRES_LIMIT_SGD = 553; /// 
   public static final int RLN_OPTIMISER_IGNORE_HELICAL_SYMMETRY = 554; /// 
   public static final int RLN_OPTIMISER_HELICAL_KEEP_TILT_PRIOR_FIXED = 555; /// 
   public static final int RLN_OPTIMISER_HIGHRES_LIMIT_EXP = 556; /// 
   public static final int RLN_OPTIMISER_IGNORE_CTF_UNTIL_FIRST_PEAK = 557; /// 
   public static final int RLN_OPTIMISER_INCR_SIZE = 558; /// 
   public static final int RLN_OPTIMISER_ITERATION_NO = 559; /// 
   public static final int RLN_OPTIMISER_LOCAL_SYMMETRY_FILENAME = 560; /// 
   public static final int RLN_OPTIMISER_LOWRES_JOIN_RANDOM_HALVES = 561; /// 
   public static final int RLN_OPTIMISER_MAGNIFICATION_RANGE = 562; /// 
   public static final int RLN_OPTIMISER_MAGNIFICATION_STEP = 563; /// 
   public static final int RLN_OPTIMISER_MAX_COARSE_SIZE = 564; /// 
   public static final int RLN_OPTIMISER_MAX_NR_POOL = 565; /// 
   public static final int RLN_OPTIMISER_MODEL_STARFILE = 566; /// 
   public static final int RLN_OPTIMISER_MODEL_STARFILE2 = 567; /// 
   public static final int RLN_OPTIMISER_NR_ITERATIONS = 568; /// 
   public static final int RLN_OPTIMISER_NR_ITER_WO_RESOL_GAIN = 569; /// 
   public static final int RLN_OPTIMISER_NR_ITER_WO_HIDDEN_VAR_CHANGES = 570; /// 
   public static final int RLN_OPTIMISER_OUTPUT_ROOTNAME = 571; /// 
   public static final int RLN_OPTIMISER_PARTICLE_DIAMETER = 572; /// 
   public static final int RLN_OPTIMISER_RADIUS_MASK_3D_MAP = 573; /// 
   public static final int RLN_OPTIMISER_RADIUS_MASK_EXP_PARTICLES = 574; /// 
   public static final int RLN_OPTIMISER_RANDOM_SEED = 575; /// 
   public static final int RLN_OPTIMISER_REFS_ARE_CTF_CORRECTED = 576; /// 
   public static final int RLN_OPTIMISER_SAMPLING_STARFILE = 577; /// 
   public static final int RLN_OPTIMISER_SGD_MU = 578; /// 
   public static final int RLN_OPTIMISER_SGD_SIGMA2FUDGE_INI = 579; /// 
   public static final int RLN_OPTIMISER_SGD_SIGMA2FUDGE_HALFLIFE = 580; /// 
   public static final int RLN_OPTIMISER_SGD_SUBSET_START = 581; /// 
   public static final int RLN_OPTIMISER_SGD_SUBSET_SIZE = 582; /// 
   public static final int RLN_OPTIMISER_SGD_WRITE_EVERY_SUBSET = 583; /// 
   public static final int RLN_OPTIMISER_SGD_MAX_SUBSETS = 584; /// 
   public static final int RLN_OPTIMISER_SGD_STEPSIZE = 585; /// 
   public static final int RLN_OPTIMISER_SMALLEST_CHANGES_OPT_CLASSES = 586; /// 
   public static final int RLN_OPTIMISER_SMALLEST_CHANGES_OPT_OFFSETS = 587; /// 
   public static final int RLN_OPTIMISER_SMALLEST_CHANGES_OPT_ORIENTS = 588; /// 
   public static final int RLN_OPTIMISER_SOLVENT_MASK_NAME = 589; /// 
   public static final int RLN_OPTIMISER_SOLVENT_MASK2_NAME = 590; /// 
   public static final int RLN_OPTIMISER_TAU_SPECTRUM_NAME = 591; /// 
   public static final int RLN_OPTIMISER_USE_TOO_COARSE_SAMPLING = 592; /// 
   public static final int RLN_OPTIMISER_WIDTH_MASK_EDGE = 593; /// 
   public static final int RLN_ORIENT_FLIP = 594; /// 
   public static final int RLN_ORIENT_ID = 595; /// 
   public static final int RLN_ORIENT_ORIGIN_X = 596; /// 
   public static final int RLN_ORIENT_ORIGIN_X_PRIOR = 597; /// 
   public static final int RLN_ORIENT_ORIGIN_Y = 598; /// 
   public static final int RLN_ORIENT_ORIGIN_Y_PRIOR = 599; /// 
   public static final int RLN_ORIENT_ORIGIN_Z = 600; /// 
   public static final int RLN_ORIENT_ORIGIN_Z_PRIOR = 601; /// 
   public static final int RLN_ORIENT_ROT = 602; /// 
   public static final int RLN_ORIENT_ROT_PRIOR = 603; /// 
   public static final int RLN_ORIENT_TILT = 604; /// 
   public static final int RLN_ORIENT_TILT_PRIOR = 605; /// 
   public static final int RLN_ORIENT_PSI = 606; /// 
   public static final int RLN_ORIENT_PSI_PRIOR = 607; /// 
   public static final int RLN_ORIENT_PSI_PRIOR_FLIP_RATIO = 608; /// 
   public static final int RLN_PARTICLE_AUTOPICK_FOM = 609; /// 
   public static final int RLN_PARTICLE_CLASS = 610; /// 
   public static final int RLN_PARTICLE_DLL = 611; /// 
   public static final int RLN_PARTICLE_ID = 612; /// 
   public static final int RLN_PARTICLE_FOM = 613; /// 
   public static final int RLN_PARTICLE_KL_DIVERGENCE = 614; /// 
   public static final int RLN_PARTICLE_MOVIE_RUNNING_AVG = 615; /// 
   public static final int RLN_PARTICLE_RANDOM_SUBSET = 616; /// 
   public static final int RLN_PARTICLE_NAME = 617; /// 
   public static final int RLN_PARTICLE_ORI_NAME = 618; /// 
   public static final int RLN_PARTICLE_NR_SIGNIFICANT_SAMPLES = 619; /// 
   public static final int RLN_PARTICLE_NR_FRAMES = 620; /// 
   public static final int RLN_PARTICLE_NR_FRAMES_AVG = 621; /// 
   public static final int RLN_PARTICLE_PMAX = 622; /// 
   public static final int RLN_PARTICLE_HELICAL_TUBE_ID = 623; /// 
   public static final int RLN_PARTICLE_HELICAL_TUBE_PITCH = 624; /// 
   public static final int RLN_PARTICLE_HELICAL_TRACK_LENGTH = 625; /// 
   public static final int RLN_PIPELINE_JOB_COUNTER = 626; /// 
   public static final int RLN_PIPELINE_NODE_NAME = 627; /// 
   public static final int RLN_PIPELINE_NODE_TYPE = 628; /// 
   public static final int RLN_PIPELINE_PROCESS_ALIAS = 629; /// 
   public static final int RLN_PIPELINE_PROCESS_NAME = 630; /// 
   public static final int RLN_PIPELINE_PROCESS_TYPE = 631; /// 
   public static final int RLN_PIPELINE_PROCESS_STATUS = 632; /// 
   public static final int RLN_PIPELINE_EDGE_FROM = 633; /// 
   public static final int RLN_PIPELINE_EDGE_TO = 634; /// 
   public static final int RLN_PIPELINE_EDGE_PROCESS = 635; /// 
   public static final int RLN_POSTPROCESS_AMPLCORR_MASKED = 636; /// 
   public static final int RLN_POSTPROCESS_AMPLCORR_UNMASKED = 637; /// 
   public static final int RLN_POSTPROCESS_BFACTOR = 638; /// 
   public static final int RLN_POSTPROCESS_DPR_MASKED = 639; /// 
   public static final int RLN_POSTPROCESS_DPR_UNMASKED = 640; /// 
   public static final int RLN_POSTPROCESS_FINAL_RESOLUTION = 641; /// 
   public static final int RLN_POSTPROCESS_FSC_GENERAL = 642; /// 
   public static final int RLN_POSTPROCESS_FSC_TRUE = 643; /// 
   public static final int RLN_POSTPROCESS_FSC_MASKED = 644; /// 
   public static final int RLN_POSTPROCESS_FSC_UNMASKED = 645; /// 
   public static final int RLN_POSTPROCESS_FSC_RANDOM_MASKED = 646; /// 
   public static final int RLN_POSTPROCESS_GUINIER_FIT_CORRELATION = 647; /// 
   public static final int RLN_POSTPROCESS_GUINIER_FIT_INTERCEPT = 648; /// 
   public static final int RLN_POSTPROCESS_GUINIER_FIT_SLOPE = 649; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_IN = 650; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_INVMTF = 651; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_WEIGHTED = 652; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_SHARPENED = 653; /// 
   public static final int RLN_POSTPROCESS_GUINIER_VALUE_INTERCEPT = 654; /// 
   public static final int RLN_POSTPROCESS_GUINIER_RESOL_SQUARED = 655; /// 
   public static final int RLN_POSTPROCESS_MTF_VALUE = 656;  /// < Detector MTF value
   public static final int RLN_SAMPLING_IS_3D = 657; /// 
   public static final int RLN_SAMPLING_IS_3D_TRANS = 658; /// 
   public static final int RLN_SAMPLING_HEALPIX_ORDER = 659; /// 
   public static final int RLN_SAMPLING_HELICAL_OFFSET_STEP = 660; /// 
   public static final int RLN_SAMPLING_LIMIT_TILT = 661; /// 
   public static final int RLN_SAMPLING_OFFSET_RANGE = 662; /// 
   public static final int RLN_SAMPLING_OFFSET_STEP = 663; /// 
   public static final int RLN_SAMPLING_PERTURB = 664; /// 
   public static final int RLN_SAMPLING_PERTURBATION_FACTOR = 665; /// 
   public static final int RLN_SAMPLING_PRIOR_MODE = 666; /// 
   public static final int RLN_SAMPLING_PSI_STEP = 667; /// 
   public static final int RLN_SAMPLING_SIGMA_ROT = 668; /// 
   public static final int RLN_SAMPLING_SIGMA_TILT = 669; /// 
   public static final int RLN_SAMPLING_SIGMA_PSI = 670; /// 
   public static final int RLN_SAMPLING_SYMMETRY = 671; /// 
   public static final int RLN_SELECTED = 672; /// 
   public static final int RLN_SELECT_PARTICLES_ZSCORE = 673; /// 
   public static final int RLN_SORTED_IDX = 674; /// 
   public static final int RLN_STARFILE_MOVIE_PARTICLES = 675; /// 
   public static final int RLN_PERFRAME_CUMULATIVE_WEIGHT = 676; /// 
   public static final int RLN_PERFRAME_RELATIVE_WEIGHT = 677; /// 
   public static final int RLN_RESOLUTION = 678; /// 
   public static final int RLN_RESOLUTION_ANGSTROM = 679; /// 
   public static final int RLN_RESOLUTION_INVPIXEL = 680; /// 
   public static final int RLN_SPECTRAL_IDX = 681; /// 
   public static final int BSOFT_ID = 682; /// 
   public static final int BSOFT_PROJECT = 683; /// 
   public static final int BSOFT_FIELD = 684; /// 
   public static final int BSOFT_FIELD_ID = 685; /// 
   public static final int BSOFT_MAP = 686; /// 
   public static final int BSOFT_MAP_ID = 687; /// 
   public static final int BSOFT_MAP_REFERENCE = 688; /// 
   public static final int BSOFT_MAP_RECONSTRUCTION = 689; /// 
   public static final int BSOFT_MAP_TRANSFORM_FILE = 690; /// 
   public static final int BSOFT_MAP_POWERSPEC_FILE = 691; /// 
   public static final int BSOFT_MAP_SIZE_X = 692; /// 
   public static final int BSOFT_MAP_SIZE_Y = 693; /// 
   public static final int BSOFT_MAP_SIZE_Z = 694; /// 
   public static final int BSOFT_MAP_ORIGIN_X = 695; /// 
   public static final int BSOFT_MAP_ORIGIN_Y = 696; /// 
   public static final int BSOFT_MAP_ORIGIN_Z = 697; /// 
   public static final int BSOFT_MAP_SCALE_X = 698; /// 
   public static final int BSOFT_MAP_SCALE_Y = 699; /// 
   public static final int BSOFT_MAP_SCALE_Z = 700; /// 
   public static final int BSOFT_MAP_VOXEL_SIZE = 701; /// 
   public static final int BSOFT_MAP_SELECT = 702; /// 
   public static final int BSOFT_MAP_FOM = 703; /// 
   public static final int BSOFT_MAP_MAGNIFICATION = 704; /// 
   public static final int BSOFT_MAP_VIEW_X = 705; /// 
   public static final int BSOFT_MAP_VIEW_Y = 706; /// 
   public static final int BSOFT_MAP_VIEW_Z = 707; /// 
   public static final int BSOFT_MAP_VIEW_ANGLE = 708; /// 
   public static final int BSOFT_MAP_BACK_RWEIGHT = 709; /// 
   public static final int BSOFT_MAP_MODEL = 710; /// 
   public static final int BSOFT_MAP_SYMMETRY = 711; /// 
   public static final int BSOFT_MICROGRAPH_FILE = 712; /// 
   public static final int BSOFT_MICROGRAPH_PARTICLE_FILE = 713; /// 
   public static final int BSOFT_MICROGRAPH_FILAMENT_FILE = 714; /// 
   public static final int BSOFT_MICROGRAPH_TRANSFORM_FILE = 715; /// 
   public static final int BSOFT_MICROGRAPH_POWERSPEC_FILE = 716; /// 
   public static final int BSOFT_MICROGRAPH_ID = 717; /// 
   public static final int BSOFT_MICROGRAPH_FIELD_ID = 718; /// 
   public static final int BSOFT_MICROGRAPH_NUMBER = 719; /// 
   public static final int BSOFT_MICROGRAPH_SELECT = 720; /// 
   public static final int BSOFT_MICROGRAPH_FOM = 721; /// 
   public static final int BSOFT_MICROGRAPH_MAGNIFICATION = 722; /// 
   public static final int BSOFT_MICROGRAPH_SAMPLING = 723; /// 
   public static final int BSOFT_MICROGRAPH_PIXEL = 724; /// 
   public static final int BSOFT_MICROGRAPH_UNITS = 725; /// 
   public static final int BSOFT_MICROGRAPH_DOSE = 726; /// 
   public static final int BSOFT_MICROGRAPH_ORIGIN_X = 727; /// 
   public static final int BSOFT_MICROGRAPH_ORIGIN_Y = 728; /// 
   public static final int BSOFT_MICROGRAPH_ORIGIN_Z = 729; /// 
   public static final int BSOFT_MICROGRAPH_SCALE_X = 730; /// 
   public static final int BSOFT_MICROGRAPH_SCALE_Y = 731; /// 
   public static final int BSOFT_MICROGRAPH_SCALE_Z = 732; /// 
   public static final int BSOFT_MICROGRAPH_TILT_AXIS = 733; /// 
   public static final int BSOFT_MICROGRAPH_TILT_ANGLE = 734; /// 
   public static final int BSOFT_MICROGRAPH_LEVEL_ANGLE = 735; /// 
   public static final int BSOFT_MICROGRAPH_ROT_ANGLE = 736; /// 
   public static final int BSOFT_MICROGRAPH_VIEW_X = 737; /// 
   public static final int BSOFT_MICROGRAPH_VIEW_Y = 738; /// 
   public static final int BSOFT_MICROGRAPH_VIEW_Z = 739; /// 
   public static final int BSOFT_MICROGRAPH_VIEW_ANGLE = 740; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_1_1 = 741; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_1_2 = 742; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_1_3 = 743; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_2_1 = 744; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_2_2 = 745; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_2_3 = 746; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_3_1 = 747; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_3_2 = 748; /// 
   public static final int BSOFT_MICROGRAPH_MATRIX_3_3 = 749; /// 
   public static final int BSOFT_MICROGRAPH_HVEC_X = 750; /// 
   public static final int BSOFT_MICROGRAPH_HVEC_Y = 751; /// 
   public static final int BSOFT_MICROGRAPH_HVEC_Z = 752; /// 
   public static final int BSOFT_MICROGRAPH_KVEC_X = 753; /// 
   public static final int BSOFT_MICROGRAPH_KVEC_Y = 754; /// 
   public static final int BSOFT_MICROGRAPH_KVEC_Z = 755; /// 
   public static final int BSOFT_MICROGRAPH_LVEC_X = 756; /// 
   public static final int BSOFT_MICROGRAPH_LVEC_Y = 757; /// 
   public static final int BSOFT_MICROGRAPH_LVEC_Z = 758; /// 
   public static final int BSOFT_MICROGRAPH_HELIX_AXIS = 759; /// 
   public static final int BSOFT_MICROGRAPH_HELIX_RISE = 760; /// 
   public static final int BSOFT_MICROGRAPH_HELIX_ANGLE = 761; /// 
   public static final int BSOFT_MICROGRAPH_HELIX_RADIUS = 762; /// 
   public static final int BSOFT_MICROGRAPH_VOLTAGE = 763; /// 
   public static final int BSOFT_MICROGRAPH_CTF_CS = 764; /// 
   public static final int BSOFT_MICROGRAPH_CTF_CC = 765; /// 
   public static final int BSOFT_MICROGRAPH_CTF_ALPHA = 766; /// 
   public static final int BSOFT_MICROGRAPH_CTF_DE = 767; /// 
   public static final int BSOFT_MICROGRAPH_CTF_AMP_CONT = 768; /// 
   public static final int BSOFT_MICROGRAPH_CTF_ZERO = 769; /// 
   public static final int BSOFT_MICROGRAPH_CTF_DEF_AVG = 770; /// 
   public static final int BSOFT_MICROGRAPH_CTF_DEF_DEV = 771; /// 
   public static final int BSOFT_MICROGRAPH_CTF_DEF_MIN = 772; /// 
   public static final int BSOFT_MICROGRAPH_CTF_DEF_MAX = 773; /// 
   public static final int BSOFT_MICROGRAPH_CTF_AST_ANG = 774; /// 
   public static final int BSOFT_MICROGRAPH_CTF_BASELINE = 775; /// 
   public static final int BSOFT_MICROGRAPH_CTF_ENVELOPE = 776; /// 
   public static final int BSOFT_MICROGRAPH_BOX_RADIUS = 777; /// 
   public static final int BSOFT_MICROGRAPH_BOX_RADIUS_X = 778; /// 
   public static final int BSOFT_MICROGRAPH_BOX_RADIUS_Y = 779; /// 
   public static final int BSOFT_MICROGRAPH_BOX_RADIUS_Z = 780; /// 
   public static final int BSOFT_MICROGRAPH_BAD = 781; /// 
   public static final int BSOFT_MICROGRAPH_BAD_RADIUS = 782; /// 
   public static final int BSOFT_MICROGRAPH_BAD_X = 783; /// 
   public static final int BSOFT_MICROGRAPH_BAD_Y = 784; /// 
   public static final int BSOFT_MICROGRAPH_BAD_Z = 785; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_RADIUS = 786; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_ID = 787; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_X = 788; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_Y = 789; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_Z = 790; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_ERROR_X = 791; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_ERROR_Y = 792; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_ERROR_Z = 793; /// 
   public static final int BSOFT_MICROGRAPH_MARKER_FOM = 794; /// 
   public static final int BSOFT_MICROGRAPH_FILAMENT_WIDTH = 795; /// 
   public static final int BSOFT_MICROGRAPH_FILNODE_RADIUS = 796; /// 
   public static final int BSOFT_CTF = 797; /// 
   public static final int BSOFT_CTF_VOLTAGE = 798; /// 
   public static final int BSOFT_CTF_CS = 799; /// 
   public static final int BSOFT_CTF_CC = 800; /// 
   public static final int BSOFT_CTF_ALPHA = 801; /// 
   public static final int BSOFT_CTF_DE = 802; /// 
   public static final int BSOFT_CTF_AMP = 803; /// 
   public static final int BSOFT_CTF_ZERO = 804; /// 
   public static final int BSOFT_CTF_DEF_AVG = 805; /// 
   public static final int BSOFT_CTF_DEF_DEV = 806; /// 
   public static final int BSOFT_CTF_DEF_MIN = 807; /// 
   public static final int BSOFT_CTF_DEF_MAX = 808; /// 
   public static final int BSOFT_CTF_AST_ANG = 809; /// 
   public static final int BSOFT_CTF_BASELINE = 810; /// 
   public static final int BSOFT_CTF_ENVELOPE = 811; /// 
   public static final int BSOFT_PARTICLE = 812; /// 
   public static final int BSOFT_PARTICLE_FILE = 813; /// 
   public static final int BSOFT_PARTICLE_NUMBER = 814; /// 
   public static final int BSOFT_PARTICLE_ID = 815; /// 
   public static final int BSOFT_PARTICLE_GROUP = 816; /// 
   public static final int BSOFT_PARTICLE_MG_ID = 817; /// 
   public static final int BSOFT_PARTICLE_MG_X = 818; /// 
   public static final int BSOFT_PARTICLE_MG_Y = 819; /// 
   public static final int BSOFT_PARTICLE_MG_Z = 820; /// 
   public static final int BSOFT_PARTICLE_X = 821; /// 
   public static final int BSOFT_PARTICLE_Y = 822; /// 
   public static final int BSOFT_PARTICLE_Z = 823; /// 
   public static final int BSOFT_PARTICLE_X_ORIGIN = 824; /// 
   public static final int BSOFT_PARTICLE_Y_ORIGIN = 825; /// 
   public static final int BSOFT_PARTICLE_Z_ORIGIN = 826; /// 
   public static final int BSOFT_PARTICLE_ORIGIN_X = 827; /// 
   public static final int BSOFT_PARTICLE_ORIGIN_Y = 828; /// 
   public static final int BSOFT_PARTICLE_ORIGIN_Z = 829; /// 
   public static final int BSOFT_PARTICLE_PSI = 830; /// 
   public static final int BSOFT_PARTICLE_THETA = 831; /// 
   public static final int BSOFT_PARTICLE_PHI = 832; /// 
   public static final int BSOFT_PARTICLE_OMEGA = 833; /// 
   public static final int BSOFT_PARTICLE_VIEW_X = 834; /// 
   public static final int BSOFT_PARTICLE_VIEW_Y = 835; /// 
   public static final int BSOFT_PARTICLE_VIEW_Z = 836; /// 
   public static final int BSOFT_PARTICLE_VIEW_ANGLE = 837; /// 
   public static final int BSOFT_PARTICLE_MAGNIF = 838; /// 
   public static final int BSOFT_PARTICLE_DEFOCUS = 839; /// 
   public static final int BSOFT_PARTICLE_DEF_DEV = 840; /// 
   public static final int BSOFT_PARTICLE_AST_ANG = 841; /// 
   public static final int BSOFT_PARTICLE_SELECT = 842; /// 
   public static final int BSOFT_PARTICLE_FOM = 843; /// 
   public static final int BSOFT_PARTICLE_FOM_CV = 844; /// 
   public static final int BSOFT_PARTICLE_FOM_AVG = 845; /// 
   public static final int BSOFT_PARTICLE_FOM_STD = 846; /// 
   public static final int BSOFT_PARTICLE_HANDA_FOM = 847; /// 
   public static final int BSOFT_PARTICLE_HANDB_FOM = 848; /// 
   public static final int BSOFT_PARTICLE_CC = 849; /// 
   public static final int BSOFT_PARTICLE_PFT_CC = 850; /// 
   public static final int BSOFT_PARTICLE_PRJ_CC = 851; /// 
   public static final int BSOFT_PARTICLE_CMP_CC = 852; /// 
   public static final int BSOFT_PARTICLE_RFACTORAB = 853; /// 
   public static final int BSOFT_PARTICLE_COVERAGE = 854; /// 
   public static final int BSOFT_PARTICLE_BOX_SIZE = 855; /// 
   public static final int BSOFT_PARTICLE_BOX_SIZE_X = 856; /// 
   public static final int BSOFT_PARTICLE_BOX_SIZE_Y = 857; /// 
   public static final int BSOFT_PARTICLE_BOX_SIZE_Z = 858; /// 
   public static final int BSOFT_PARTICLE_BOX_RADIUS = 859; /// 
   public static final int BSOFT_PARTICLE_BOX_RADIUS_X = 860; /// 
   public static final int BSOFT_PARTICLE_BOX_RADIUS_Y = 861; /// 
   public static final int BSOFT_PARTICLE_BOX_RADIUS_Z = 862; /// 
   public static final int BSOFT_PARTICLE_BAD = 863; /// 
   public static final int BSOFT_PARTICLE_BAD_RADIUS = 864; /// 
   public static final int BSOFT_PARTICLE_BAD_X = 865; /// 
   public static final int BSOFT_PARTICLE_BAD_Y = 866; /// 
   public static final int BSOFT_PARTICLE_BAD_Z = 867; /// 
   public static final int BSOFT_FILAMENT = 868; /// 
   public static final int BSOFT_FILAMENT_FILE = 869; /// 
   public static final int BSOFT_FILAMENT_ID = 870; /// 
   public static final int BSOFT_FILAMENT_NODE = 871; /// 
   public static final int BSOFT_FILAMENT_NODE_ID = 872; /// 
   public static final int BSOFT_FILAMENT_NODE_X = 873; /// 
   public static final int BSOFT_FILAMENT_NODE_Y = 874; /// 
   public static final int BSOFT_FILAMENT_NODE_Z = 875; /// 
   public static final int BSOFT_FILAMENT_WIDTH = 876; /// 
   public static final int BSOFT_FILNODE_RADIUS = 877; /// 
   public static final int BSOFT_ORIENT_ID = 878; /// 
   public static final int BSOFT_ORIENT_ORIGIN_X = 879; /// 
   public static final int BSOFT_ORIENT_ORIGIN_Y = 880; /// 
   public static final int BSOFT_ORIENT_ORIGIN_Z = 881; /// 
   public static final int BSOFT_ORIENT_VIEW_X = 882; /// 
   public static final int BSOFT_ORIENT_VIEW_Y = 883; /// 
   public static final int BSOFT_ORIENT_VIEW_Z = 884; /// 
   public static final int BSOFT_ORIENT_VIEW_ANGLE = 885; /// 
   public static final int BSOFT_ORIENT_FOM = 886; /// 
   public static final int BSOFT_ORIENT_SELECT = 887; /// 
   public static final int BSOFT_MARKER = 888; /// 
   public static final int BSOFT_MARKER_RADIUS = 889; /// 
   public static final int BSOFT_MARKER_ID = 890; /// 
   public static final int BSOFT_MARKER_X = 891; /// 
   public static final int BSOFT_MARKER_Y = 892; /// 
   public static final int BSOFT_MARKER_Z = 893; /// 
   public static final int BSOFT_MARKER_ERROR_X = 894; /// 
   public static final int BSOFT_MARKER_ERROR_Y = 895; /// 
   public static final int BSOFT_MARKER_ERROR_Z = 896; /// 
   public static final int BSOFT_MARKER_IMAGE = 897; /// 
   public static final int BSOFT_MARKER_RESIDUAL = 898; /// 
   public static final int BSOFT_MARKER_FOM = 899; /// 
   public static final int BSOFT_MARKER_SELECT = 900; /// 
   public static final int BSOFT_REFLEX = 901; /// 
   public static final int BSOFT_REFLEX_RADIUS = 902; /// 
   public static final int BSOFT_REFLEX_X = 903; /// 
   public static final int BSOFT_REFLEX_Y = 904; /// 
   public static final int BSOFT_REFLEX_Z = 905; /// 
   public static final int BSOFT_REFLEX_H = 906; /// 
   public static final int BSOFT_REFLEX_K = 907; /// 
   public static final int BSOFT_REFLEX_L = 908; /// 
   public static final int BSOFT_REFLEX_AMP = 909; /// 
   public static final int BSOFT_REFLEX_SIGAMP = 910; /// 
   public static final int BSOFT_REFLEX_PHI = 911; /// 
   public static final int BSOFT_REFLEX_SIGPHI = 912; /// 
   public static final int BSOFT_REFLEX_FOM = 913; /// 
   public static final int BSOFT_REFLEX_STATUS = 914; /// 
   public static final int BSOFT_LAYERLINE = 915; /// 
   public static final int BSOFT_LAYERLINE_NUMBER = 916; /// 
   public static final int BSOFT_LAYERLINE_ORDER = 917; /// 
   public static final int BSOFT_LAYERLINE_DISTANCE = 918; /// 
   public static final int BSOFT_LAYERLINE_FREQ = 919; /// 
   public static final int BSOFT_LAYERLINE_AMP = 920; /// 
   public static final int BSOFT_LAYERLINE_FOM = 921; /// 
   public static final int BSOFT_LAYERLINE_SELECT = 922; /// 
   public static final int BSOFT_SYMMETRY_INT_TABLES_NUMBER = 923; /// 
   public static final int BSOFT_SYMMETRY_SPACE_GROUP_NAME_H_M = 924; /// 
   public static final int BSOFT_SYMMETRY_CELL_SETTING = 925; /// 
   public static final int BSOFT_SYMMETRY_EQUIV_ID = 926; /// 
   public static final int BSOFT_SYMMETRY_EQUIV_POS_AS_XYZ = 927; /// 
   public static final int MDL_LAST_LABEL = 928;  // **** NOTE ****: Do keep this label always at the end;it is here for looping purposes /// 
}
